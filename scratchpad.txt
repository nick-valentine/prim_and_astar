//Old update for mazemaker
/*
int rand_wall = rand() % wall_list_x_.size();
		int x = wall_list_x_[ rand_wall ];
		int y = wall_list_y_[ rand_wall ];
		
		Side touching = find_touching_maze( maze, x, y );
		
		int other_side_x = x, other_side_y = y;
		int success;
		if( success = traverse( invert_side(touching), &other_side_x, &other_side_y ) )
		{
		
		//std::cout<<x<<", "<<y<<" "<<other_side_x<<", "<<other_side_y<<" "<<invert_side(touching)<<" "<<success<<" "<<find_maze_list(other_side_x, other_side_y)<<std::endl;
		
			//only perform if the traversal was successful
		
			//if the other side is not yet in the maze
			if( find_maze_list( other_side_x, other_side_y ) == -1 )
			{
				//make the wall a passage
				maze[ index(x, y, width_ ) ].setState( MazeElement::Floor );
				maze_list_x_.push_back( x );
				maze_list_y_.push_back( y );
				
				//mark the cell on the opposite side as part of the maze
				//maze_list_x_.push_back( other_side_x );
				//maze_list_y_.push_back( other_side_y );
				#ifdef CHANGE_COLOR
					//maze[ index( other_side_x, other_side_y, width_ ) ].setColor( maze_list );
				#endif
			
				//add neighboring walls to the wall list
				add_walls( maze, x, y );
			}
			/*
			for(unsigned int i = 0; i < wall_list_x_.size(); ++i)
			{
				std::cout<<"( "<<wall_list_x_[i]<<", "<<wall_list_y_[i]<<" ) , ";
			}
			std::cout<<"\n";
			*/
			/*
			for(unsigned int i = 0; i < maze_list_x_.size(); ++i)
			{
				std::cout<<"( "<<maze_list_x_[i]<<", "<<maze_list_y_[i]<<" ) , ";
			}
			std::cout<<"\n";
			*/
		}
		
		//remove the wall from the wall list
		#ifdef CHANGE_COLOR
			maze[ index( x, y, width_ ) ].resetColor();
		#endif
		wall_list_x_[ rand_wall ] = wall_list_x_[ wall_list_x_.size() - 1 ];
		wall_list_y_[ rand_wall ] = wall_list_y_[ wall_list_y_.size() - 1 ];
		wall_list_x_.pop_back();
		wall_list_y_.pop_back();
		
		//sf::sleep( sf::milliseconds( 1000 ) );
